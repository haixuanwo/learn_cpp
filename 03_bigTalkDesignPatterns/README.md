<!--
 * @Author: Clark
 * @Email: haixuanwoTxh@gmail.com
 * @Date: 2024-02-23 09:21:31
 * @LastEditors: Clark
 * @LastEditTime: 2024-02-28 18:06:46
 * @Description: file content
-->


# 设计原则

## 1 依赖倒置（DIP）
- 高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）
- 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）

## 2 开放封闭原则（OCP）
- 对扩展开放，对更改封闭
- 类模块应该是可扩展的，但不可修改

##  3 单一职责（SRP）
- 一个类应只有一个引起变化的原因
- 变化的方向隐含着类的责任

## 4 Liskov替换原则（LSP）
- 子类必须能够替换他们的基类（IS-A）
- 继承表达类型的抽象

## 5 接口隔离原则（ISP）
- 不依赖不用的方法
- 接口小而完备

## 6 面向对象设计原则
优先使用对象组合，而不是类继承
- 类继承通常为“白箱复用”
- 类继承破坏封装性，子类父类耦合度高
- 组合只要求良好定义的接口，耦合度低

## 7 面向对象设计原则
封装变化点
- 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不影响另一侧，实现层次间松耦合

## 8 面向对象设计原则
针对接口编程，而不是针对实现编程
- 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
- 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。
- 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。


# 将设计原则提升为设计经验
## 1. 设计习语 Design Idioms
- Design Idioms 描述与特定编程语言相关的低层模式，技巧，惯用法。

## 2. 设计模式 Design Patterns
- Design Patterns主要描述的是“类与相互通信的对象之间的组织关系，包括它们的角色、职责、协作方式等方面。

## 3. 架构模式 Architectural Patterns
- Architectural Patterns描述系统中与基本结构组织关系密切的高层模式，包括子系统划分，职责，以及如何组织它们之间关系的规则。


# 设计模式

## 01 简单工厂【Simple factory】
专门定义一个类（工厂类）来负责创建其他类的实例。
可根据创建方法的参数来返回不同类的实例，被创建的实例通常都具有共同的父类。

## 02 策略【Strategy】
定义一系列算法，并将每个算法封装起来，使他们可以相互替换，切算法的变化不会影响到使用算法的客户

## 03 装饰【Decorate】
动态的将新功能附加到对象上。在对象功能扩展方面，比继承更有弹性。

## 04 代理【Proxy】
给对象提供一个代理对象，并由代理对象控制对原对象的引用。

## 05 工厂方法【Factory method】
工厂父类负责定义创建产品对象的公共接口，工厂子类负责生成具体的产品对象。
即通过不同的子类来创建不同的产品对象。

## 06 原型【Prototype】
通过赋值现有实例来创建新的示例

## 07 模板方法【Template method】
定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变算法的结构即可重定义该算法的步骤

## 08 外观【Facade】
隐藏了系统复杂性，并向客户端提供了一个可以访问系统的接口。

## 09 建造者【Builder】
将一个复杂对象的构造与他的表示分离，使同样的构建过程可以创建不同的表示

## 10 观察者【Observer】
定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题。
主题发生变化时，通知所有观察者，使其更新自己

## 11 抽象工厂【Abstract factory】

## 12 状态【State】
在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的context对象。
简单理解，一个拥有状态的context对象，在不同状态下，其行为会发生改变。

## 13 适配器【Adapter】
将类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。

## 14 备忘录【Memento】
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，
以便以后当需要时能将该对象恢复到原先保存的状态。

## 15 组合【Composite】
部分与整体模式，将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系。
使得用户对单个对象和组合对象具有一致的访问性

## 16 迭代器模式【Iterator】
提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示

## 17 单例【Singleton】
确保一个类最多只有一个实例，并提供一个全局访问点
分两种：预加载和懒加载

## 18 桥接模式【Bridge】
将抽象部分与他的实现部分分离，使它们可以独立的变化

## 19 命令【Command】
将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加、管理
将请求封装成对象，使你可以用不同的请求对客户进行参数化

## 20 职责链模式【Chain of responsebility】
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

## 21 中介者模式【Mediator】
用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。

## 22 享元【Flyweight】
通过共享的方式高效的支持大量细颗粒的对象。重用对象节省内存资源。


## 23 解释器模式【Interpreter】
给定一个语言，定义他的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子

## 24 访问者模式【Visitor】
表示一个作用于某对象结构中的各元素的操作。它使你不改变类元素的前提下定义作用于这些元素的新操作。
